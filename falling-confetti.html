<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Magnetic Confetti</title>

    <style>
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js"></script>

    <script>

        document.addEventListener("DOMContentLoaded", function() {

            var mouseX = 0,
                mouseY = 0;

            // renderer
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xFFFFFF);
            document.body.appendChild(renderer.domElement);

            // scene
            var scene = new THREE.Scene();

            // camera
            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 400;

            var planes = [];
            var planeColors = [0xDBDBD2, 0xFCE7DD, 0xF0E4C9, 0xF0E4C9, 0xFCBD8D, 0xE3C47C];
            var lastPosX = 0;
            var lastPosY = -window.innerHeight/2;//0;

            for (var i = 0 ; i < 10000; i++) {

                // create a geometry
                var geometry = new THREE.BoxGeometry( 5, 5, 0.1 );

                // add a material to the mesh
                var randomColor = planeColors[Math.floor(Math.random()*planeColors.length)];

                var material;
                if (randomColor == 0x98782c) {
                    material = new THREE.MeshPhongMaterial({color: randomColor, emissive:0x111102, specular:randomColor, shininess:100});
                } else {
                    material = new THREE.MeshBasicMaterial({color: randomColor});
                }

                // create a mesh by combining the geometry and material
                var plane = new THREE.Mesh(geometry, material);
                if (lastPosX >= window.innerWidth) {
                    lastPosX = -window.innerWidth/2;
                    lastPosY += 20;
                }
                plane.position.x = lastPosX + 10 + Math.random() * 10;
                plane.position.y = lastPosY + Math.random() * 20 - 10;
                plane.rotation.z = (Math.random() * 360) * (Math.PI/180);

                lastPosX = plane.position.x;

                // exit the loop if we're creating triangles outside the window size
                if (lastPosY > window.innerHeight/2) {
                    break;
                }

                // add the mesh to the scene
                scene.add(plane);

                var delay = Math.random()*2.5;
                if (delay > 2.45) {
                    delay += 1.5 * Math.random();
                }
                TweenMax.from(plane.position, 4.5, {y:200, z:410, ease:"Power3.easeIn", delay:delay});
                TweenMax.from(plane.rotation, 4.5, {x:Math.random()*100, y:Math.random()*100, z:Math.random()*100, ease:"Linear.easeNone", delay:delay, onCompleteParams:[plane], onComplete:function(p) {
                    var addlRotation = p.rotation.z + ((Math.random()*90-90)*(Math.PI/180));
                    TweenMax.to(p.rotation, Math.random()*0.5, {z:addlRotation});
                    TweenMax.to(p.position, 0.05+Math.random()*0.05, {z:Math.random()*5, ease:"Sine.easeOut", yoyo:true, repeat:1});
                }});

                planes.push(plane);
            }


            // in order to see what's in our scene, we need a light source
//            var pointerOne = new THREE.PointLight(0xFFFFFF);
            var pointerOne = new THREE.HemisphereLight(0xffffbb, 0x080820, 1.1);
            pointerOne.position.set(-100,-90,130);

            // add the light to the scene
            scene.add(pointerOne);

            var render = function () {
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }

//            for (var i = 0; i < planes.length; i++) {
//                planes[i].rotation.z = -calculatePlaneRotation(planes[i].position.x, planes[i].position.y)*(Math.PI/180);
//                    planes[i].rotation.z = calculatePlaneRotation(planes[i].position.x, planes[i].position.y);
//                    console.log(planes[i].rotation.z);
//            }

//            function calculatePlaneRotation(x, y) {
//                console.log("(" + x + ", " + y + ") atan = " + Math.atan((y)/(x)));
//                return Math.atan((y-window.innerHeight/2)/(x-window.innerWidth/2));
//            }

            render();

//            document.onmousemove = function (e) {
//                mouseX = e.clientX - window.innerWidth/2;
//                mouseY = e.clientY - window.innerHeight/2;
//            };

        });

    </script>
</body>
</html>